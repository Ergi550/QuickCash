import { query, transaction } from '../database/Connection';
import { Product, Category, ProductDTO, CategoryDTO, InventoryUpdateDTO, Inventory } from '../models/product.model';
import { AppError } from '../middleware/error.middleware';

/**
 * Product Service
 * Handles product, category and inventory management with PostgreSQL
 */
class ProductService {
  // ==================== PRODUCTS ====================

  /**
   * Get all products with inventory and category info
   */
  async getAllProducts(isAvailable?: boolean): Promise<Product[]> {
    let queryText = `
      SELECT p.*, 
             c.category_name,
             COALESCE(i.current_quantity, 0) as current_quantity
      FROM products p
      LEFT JOIN categories c ON p.category_id = c.category_id
      LEFT JOIN inventory i ON p.product_id = i.product_id
    `;
    const params: any[] = [];

    if (isAvailable !== undefined) {
      queryText += ' WHERE p.is_available = $1';
      params.push(isAvailable);
    }

    queryText += ' ORDER BY p.sort_order, p.product_name';

    const result = await query(queryText, params);
    return result.rows;
  }

  /**
   * Get product by ID
   */
  async getProductById(productId: number): Promise<Product> {
    const result = await query(
      `SELECT p.*, 
              c.category_name,
              COALESCE(i.current_quantity, 0) as current_quantity
       FROM products p
       LEFT JOIN categories c ON p.category_id = c.category_id
       LEFT JOIN inventory i ON p.product_id = i.product_id
       WHERE p.product_id = $1`,
      [productId]
    );

    if (result.rows.length === 0) {
      throw new AppError('Produkti nuk u gjet', 404);
    }

    return result.rows[0];
  }

  /**
   * Get products by category
   */
  async getProductsByCategory(categoryId: number): Promise<Product[]> {
    const result = await query(
      `SELECT p.*, 
              c.category_name,
              COALESCE(i.current_quantity, 0) as current_quantity
       FROM products p
       LEFT JOIN categories c ON p.category_id = c.category_id
       LEFT JOIN inventory i ON p.product_id = i.product_id
       WHERE p.category_id = $1
       ORDER BY p.sort_order, p.product_name`,
      [categoryId]
    );
    return result.rows;
  }

  /**
   * Search products
   */
  async searchProducts(searchTerm: string): Promise<Product[]> {
    const result = await query(
      `SELECT p.*, 
              c.category_name,
              COALESCE(i.current_quantity, 0) as current_quantity
       FROM products p
       LEFT JOIN categories c ON p.category_id = c.category_id
       LEFT JOIN inventory i ON p.product_id = i.product_id
       WHERE p.product_name ILIKE $1 
          OR p.description ILIKE $1
          OR p.product_code ILIKE $1
       ORDER BY p.product_name`,
      [`%${searchTerm}%`]
    );
    return result.rows;
  }

  /**
   * Create new product with inventory
   */
  async createProduct(productData: ProductDTO): Promise<Product> {
    return transaction(async (client) => {
      // Generate product code if not provided
      const productCode = productData.product_code || `PRD-${Date.now()}`;

      // Insert product (profit_margin is auto-generated by database)
      const productResult = await client.query(
        `INSERT INTO products (
          category_id, product_code, product_name, description, image_url,
          unit_type, cost_price, selling_price, tax_rate,
          is_available, is_featured, preparation_time
        )
        VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12)
        RETURNING *`,
        [
          productData.category_id || null,
          productCode,
          productData.product_name,
          productData.description || null,
          productData.image_url || null,
          productData.unit_type || 'piece',
          productData.cost_price,
          productData.selling_price,
          productData.tax_rate || 0,
          productData.is_available ?? true,
          productData.is_featured ?? false,
          productData.preparation_time || null,
        ]
      );

      const product = productResult.rows[0];

      // Create inventory record
      await client.query(
        `INSERT INTO inventory (product_id, current_quantity, minimum_quantity)
         VALUES ($1, $2, $3)`,
        [product.product_id, productData.initial_quantity || 0, 10]
      );
      const finalResult = await client.query(
      `SELECT p.*, 
              c.category_name,
              COALESCE(i.current_quantity, 0) as current_quantity
       FROM products p
       LEFT JOIN categories c ON p.category_id = c.category_id
       LEFT JOIN inventory i ON p.product_id = i.product_id
       WHERE p.product_id = $1`,
      [product.product_id]
    );

    return finalResult.rows[0];

    });
  }

  /**
   * Update product
   */
  async updateProduct(productId: number, productData: Partial<ProductDTO>): Promise<Product> {
    // profit_margin is auto-generated, so we don't update it
    const result = await query(
      `UPDATE products 
       SET category_id = COALESCE($1, category_id),
           product_name = COALESCE($2, product_name),
           description = COALESCE($3, description),
           image_url = COALESCE($4, image_url),
           unit_type = COALESCE($5, unit_type),
           cost_price = COALESCE($6, cost_price),
           selling_price = COALESCE($7, selling_price),
           tax_rate = COALESCE($8, tax_rate),
           is_available = COALESCE($9, is_available),
           is_featured = COALESCE($10, is_featured),
           preparation_time = COALESCE($11, preparation_time),
           updated_at = CURRENT_TIMESTAMP
       WHERE product_id = $12
       RETURNING *`,
      [
        productData.category_id,
        productData.product_name,
        productData.description,
        productData.image_url,
        productData.unit_type,
        productData.cost_price,
        productData.selling_price,
        productData.tax_rate,
        productData.is_available,
        productData.is_featured,
        productData.preparation_time,
        productId,
      ]
    );

    if (result.rows.length === 0) {
      throw new AppError('Produkti nuk u gjet', 404);
    }

    return this.getProductById(productId);
  }

  /**
   * Delete product
   */
  async deleteProduct(productId: number): Promise<void> {
    return transaction(async (client) => {
      // Delete inventory first
      await client.query('DELETE FROM inventory WHERE product_id = $1', [productId]);
      
      // Delete product
      const result = await client.query(
        'DELETE FROM products WHERE product_id = $1 RETURNING product_id',
        [productId]
      );

      if (result.rows.length === 0) {
        throw new AppError('Produkti nuk u gjet', 404);
      }
    });
  }

  // ==================== INVENTORY ====================

  /**
   * Update inventory
   */
  async updateInventory(updates: InventoryUpdateDTO): Promise<Inventory> {
    const { product_id, quantity, action } = updates;

    // Get current inventory
    const currentResult = await query(
      'SELECT * FROM inventory WHERE product_id = $1',
      [product_id]
    );

    if (currentResult.rows.length === 0) {
      throw new AppError('Inventory nuk u gjet për këtë produkt', 404);
    }

    const current = currentResult.rows[0];
    let newQuantity: number;

    switch (action) {
      case 'add':
        newQuantity = Number(current.current_quantity) + quantity;
        break;
      case 'subtract':
        if (Number(current.current_quantity) < quantity) {
          throw new AppError('Sasia në stok është e pamjaftueshme', 400);
        }
        newQuantity = Number(current.current_quantity) - quantity;
        break;
      case 'set':
        newQuantity = quantity;
        break;
      default:
        throw new AppError('Veprim i pavlefshëm', 400);
    }

    const result = await query(
      `UPDATE inventory 
       SET current_quantity = $1,
           updated_at = CURRENT_TIMESTAMP
       WHERE product_id = $2
       RETURNING *`,
      [newQuantity, product_id]
    );

    // Auto-disable product if out of stock
    if (newQuantity === 0) {
      await query(
        'UPDATE products SET is_available = false WHERE product_id = $1',
        [product_id]
      );
    }

    return result.rows[0];
  }

  /**
   * Check stock availability
   */
  async checkStock(productId: number, quantity: number): Promise<boolean> {
    const result = await query(
      `SELECT i.current_quantity, p.is_available
       FROM inventory i
       JOIN products p ON i.product_id = p.product_id
       WHERE i.product_id = $1`,
      [productId]
    );

    if (result.rows.length === 0) return false;

    const { current_quantity, is_available } = result.rows[0];
    return Number(current_quantity) >= quantity && is_available;
  }

  /**
   * Get low stock products
   */
  async getLowStockProducts(threshold: number = 10): Promise<Product[]> {
    const result = await query(
      `SELECT p.*, c.category_name, i.current_quantity, i.minimum_quantity
       FROM products p
       LEFT JOIN categories c ON p.category_id = c.category_id
       JOIN inventory i ON p.product_id = i.product_id
       WHERE i.current_quantity <= COALESCE(i.minimum_quantity, $1)
         AND i.current_quantity > 0
       ORDER BY i.current_quantity ASC`,
      [threshold]
    );
    return result.rows;
  }

  /**
   * Get out of stock products
   */
  async getOutOfStockProducts(): Promise<Product[]> {
    const result = await query(
      `SELECT p.*, c.category_name, i.current_quantity
       FROM products p
       LEFT JOIN categories c ON p.category_id = c.category_id
       JOIN inventory i ON p.product_id = i.product_id
       WHERE i.current_quantity = 0
       ORDER BY p.product_name`
    );
    return result.rows;
  }

  // ==================== CATEGORIES ====================

  /**
   * Get all categories
   */
  async getAllCategories(activeOnly: boolean = false): Promise<Category[]> {
    let queryText = 'SELECT * FROM categories';
    if (activeOnly) {
      queryText += ' WHERE is_active = true';
    }
    queryText += ' ORDER BY sort_order, category_name';

    const result = await query(queryText);
    return result.rows;
  }

  /**
   * Get category by ID
   */
  async getCategoryById(categoryId: number): Promise<Category> {
    const result = await query(
      'SELECT * FROM categories WHERE category_id = $1',
      [categoryId]
    );

    if (result.rows.length === 0) {
      throw new AppError('Kategoria nuk u gjet', 404);
    }

    return result.rows[0];
  }

  /**
   * Create category
   */
  async createCategory(categoryData: CategoryDTO): Promise<Category> {
    const result = await query(
      `INSERT INTO categories (category_name, parent_category_id, description, icon, sort_order, is_active)
       VALUES ($1, $2, $3, $4, $5, $6)
       RETURNING *`,
      [
        categoryData.category_name,
        categoryData.parent_category_id || null,
        categoryData.description || null,
        categoryData.icon || null,
        categoryData.sort_order || 0,
        categoryData.is_active ?? true,
      ]
    );

    return result.rows[0];
  }

  /**
   * Update category
   */
  async updateCategory(categoryId: number, categoryData: Partial<CategoryDTO>): Promise<Category> {
    const result = await query(
      `UPDATE categories 
       SET category_name = COALESCE($1, category_name),
           parent_category_id = COALESCE($2, parent_category_id),
           description = COALESCE($3, description),
           icon = COALESCE($4, icon),
           sort_order = COALESCE($5, sort_order),
           is_active = COALESCE($6, is_active),
           updated_at = CURRENT_TIMESTAMP
       WHERE category_id = $7
       RETURNING *`,
      [
        categoryData.category_name,
        categoryData.parent_category_id,
        categoryData.description,
        categoryData.icon,
        categoryData.sort_order,
        categoryData.is_active,
        categoryId,
      ]
    );

    if (result.rows.length === 0) {
      throw new AppError('Kategoria nuk u gjet', 404);
    }

    return result.rows[0];
  }

  /**
   * Delete category
   */
  async deleteCategory(categoryId: number): Promise<void> {
    // Check if category has products
    const productsResult = await query(
      'SELECT COUNT(*) as count FROM products WHERE category_id = $1',
      [categoryId]
    );

    if (parseInt(productsResult.rows[0].count) > 0) {
      throw new AppError('Nuk mund të fshihet kategoria që ka produkte', 400);
    }

    const result = await query(
      'DELETE FROM categories WHERE category_id = $1 RETURNING category_id',
      [categoryId]
    );

    if (result.rows.length === 0) {
      throw new AppError('Kategoria nuk u gjet', 404);
    }
  }

  /**
   * Get product statistics
   */
  async getProductStats(): Promise<{
    total: number;
    available: number;
    outOfStock: number;
    lowStock: number;
    byCategory: { category_name: string; count: number }[];
  }> {
    const totalResult = await query('SELECT COUNT(*) as count FROM products');
    const availableResult = await query('SELECT COUNT(*) as count FROM products WHERE is_available = true');
    const outOfStockResult = await query(
      `SELECT COUNT(*) as count FROM inventory WHERE current_quantity = 0`
    );
    const lowStockResult = await query(
      `SELECT COUNT(*) as count FROM inventory 
       WHERE current_quantity <= COALESCE(minimum_quantity, 10) AND current_quantity > 0`
    );
    const byCategoryResult = await query(
      `SELECT COALESCE(c.category_name, 'Pa kategori') as category_name, COUNT(*) as count 
       FROM products p
       LEFT JOIN categories c ON p.category_id = c.category_id
       GROUP BY c.category_name
       ORDER BY count DESC`
    );

    return {
      total: parseInt(totalResult.rows[0].count),
      available: parseInt(availableResult.rows[0].count),
      outOfStock: parseInt(outOfStockResult.rows[0].count),
      lowStock: parseInt(lowStockResult.rows[0].count),
      byCategory: byCategoryResult.rows,
    };
  }
}

export default new ProductService();